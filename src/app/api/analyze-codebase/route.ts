import { NextRequest, NextResponse } from "next/server"
import { getServerSession } from "next-auth/next"
import { authOptions } from "@/lib/auth"
import { CodebaseAnalysisService, type CodebaseAnalysis } from "@/lib/codebase-analysis-service"
import RepositoryAnalyzer from "@/lib/repository-analyzer"
import { DocumentationService } from "@/lib/database"
import OpenAI from 'openai'

interface AnalyzeCodebaseRequest {
  repositoryId: number
  repositoryName: string
  repositoryFullName: string
  analysisType?: 'performance' | 'architecture' | 'complete'
}

interface StreamEvent {
  type: 'progress' | 'complete' | 'error'
  message: string
  progress: number
  stage?: string
  data?: Record<string, unknown>
}

// Helper function to generate assessment
function getAssessment(score: number): string {
  if (score >= 8) return 'üü¢ Excellent'
  if (score >= 6) return 'üü° Good'
  if (score >= 4) return 'üü† Fair'
  return 'üî¥ Poor'
}

// Helper function to generate analysis report
async function generateAnalysisReport(analysis: CodebaseAnalysis, repositoryInfo: any, filesCount: number): Promise<string> {
  const now = new Date()
  const formattedDate = now.toLocaleDateString('en-US', { 
    year: 'numeric', 
    month: 'long', 
    day: 'numeric' 
  })

  let markdown = `<div align="center">\n\n`
  markdown += `# üîç ${repositoryInfo.name} - Codebase Analysis Report\n`
  markdown += `### AI-Powered Performance & Architecture Analysis\n\n`
  markdown += `[![GitHub](https://img.shields.io/badge/GitHub-Repository-blue?style=for-the-badge&logo=github)](https://github.com/${repositoryInfo.fullName})\n`
  markdown += `[![Score](https://img.shields.io/badge/Overall%20Score-${analysis.summary.overallScore}%2F100-${analysis.summary.overallScore >= 80 ? 'brightgreen' : analysis.summary.overallScore >= 60 ? 'yellow' : 'red'}?style=for-the-badge&logo=checkmarx)]()\n`
  markdown += `[![Issues](https://img.shields.io/badge/Major%20Issues-${analysis.summary.majorIssues}-red?style=for-the-badge&logo=alert)]()\n`
  markdown += `[![Quick Wins](https://img.shields.io/badge/Quick%20Wins-${analysis.summary.quickWins}-green?style=for-the-badge&logo=zap)]()\n\n`
  markdown += `*Generated by [CodeGenius AI](https://codegenius.dev) ‚Ä¢ ${formattedDate}*\n\n`
  markdown += `</div>\n\n`
  markdown += `---\n\n`

  // Executive Summary
  markdown += `## üìä Executive Summary\n\n`
  markdown += `| Metric | Value | Status |\n`
  markdown += `|--------|-------|--------|\n`
  markdown += `| **Overall Score** | ${analysis.summary.overallScore}/100 | ${analysis.summary.overallScore >= 80 ? 'üü¢ Excellent' : analysis.summary.overallScore >= 60 ? 'üü° Good' : 'üî¥ Needs Improvement'} |\n`
  markdown += `| **Major Issues** | ${analysis.summary.majorIssues} | ${analysis.summary.majorIssues === 0 ? 'üü¢ None' : analysis.summary.majorIssues <= 5 ? 'üü° Manageable' : 'üî¥ Critical'} |\n`
  markdown += `| **Quick Wins** | ${analysis.summary.quickWins} | ${analysis.summary.quickWins >= 5 ? 'üü¢ Many' : analysis.summary.quickWins >= 2 ? 'üü° Some' : 'üî¥ Few'} |\n`
  markdown += `| **Est. Improvement Time** | ${analysis.summary.estimatedImprovementTime} | ‚è±Ô∏è Timeline |\n`
  markdown += `| **Performance Gain** | ${analysis.summary.potentialPerformanceGain} | üöÄ Potential |\n`
  markdown += `| **Cost Savings** | ${analysis.summary.costSavings} | üí∞ ROI |\n`
  markdown += `| **Files Analyzed** | ${filesCount} | üìÅ Coverage |\n\n`

  // Performance Metrics
  markdown += `## üìà Performance Metrics\n\n`
  markdown += `### Current State\n\n`
  markdown += `| Category | Score | Assessment |\n`
  markdown += `|----------|-------|------------|\n`
  markdown += `| **Complexity** | ${analysis.metrics.overall.complexity}/10 | ${getAssessment(analysis.metrics.overall.complexity)} |\n`
  markdown += `| **Maintainability** | ${analysis.metrics.overall.maintainability}/10 | ${getAssessment(analysis.metrics.overall.maintainability)} |\n`
  markdown += `| **Performance** | ${analysis.metrics.overall.performance}/10 | ${getAssessment(analysis.metrics.overall.performance)} |\n`
  markdown += `| **Security** | ${analysis.metrics.overall.security}/10 | ${getAssessment(analysis.metrics.overall.security)} |\n`
  markdown += `| **Scalability** | ${analysis.metrics.overall.scalability}/10 | ${getAssessment(analysis.metrics.overall.scalability)} |\n\n`

  // Critical Issues
  if (analysis.bottlenecks.length > 0) {
    markdown += `## üö® Critical Issues & Bottlenecks\n\n`
    const criticalIssues = analysis.bottlenecks.filter(b => b.severity === 'critical' || b.severity === 'high')
    
    if (criticalIssues.length > 0) {
      criticalIssues.slice(0, 8).forEach((issue, index) => {
        markdown += `### ${index + 1}. ${issue.title}\n\n`
        markdown += `**Severity**: ${issue.severity.toUpperCase()} ‚Ä¢ **Type**: ${issue.type} ‚Ä¢ **Priority**: ${issue.priority}/10\n\n`
        markdown += `**Impact**: ${issue.impact}\n\n`
        markdown += `**Description**: ${issue.description}\n\n`
        markdown += `**Time to Fix**: ${issue.estimatedTimeToFix}\n\n`
        if (issue.files && issue.files.length > 0) {
          markdown += `**Affected Files**: ${issue.files.join(', ')}\n\n`
        }
        markdown += `---\n\n`
      })
    }
  }

  // Optimization Recommendations
  markdown += `## üõ†Ô∏è Optimization Recommendations\n\n`
  if (analysis.recommendations.length > 0) {
    analysis.recommendations.slice(0, 10).forEach((rec, index) => {
      markdown += `### ${index + 1}. ${rec.title}\n\n`
      markdown += `**Category**: ${rec.category} ‚Ä¢ **Priority**: ${rec.priority}/10 ‚Ä¢ **Difficulty**: ${rec.implementation.difficulty}\n\n`
      markdown += `**Description**: ${rec.description}\n\n`
      markdown += `**Benefits**:\n`
      rec.benefits.forEach(benefit => {
        markdown += `- ‚úÖ ${benefit}\n`
      })
      markdown += `\n**Implementation Time**: ${rec.implementation.timeEstimate}\n\n`
      markdown += `**Impact**:\n`
      markdown += `- üöÄ Performance: ${rec.impact.performance}/10\n`
      markdown += `- üîß Maintainability: ${rec.impact.maintainability}/10\n`
      markdown += `- üìà Scalability: ${rec.impact.scalability}/10\n`
      markdown += `- üí∞ Cost: ${rec.impact.cost}/10\n\n`
      markdown += `---\n\n`
    })
  }

  // Modernization Plan
  markdown += `## üó∫Ô∏è Modernization Roadmap\n\n`
  markdown += `### Phase 1: ${analysis.modernizationPlan.phase1.title}\n`
  markdown += `**Duration**: ${analysis.modernizationPlan.phase1.duration}\n\n`
  markdown += `**Tasks**:\n`
  analysis.modernizationPlan.phase1.tasks.forEach(task => {
    markdown += `- [ ] ${task}\n`
  })
  markdown += `\n**Expected Improvement**: ${analysis.modernizationPlan.phase1.expectedImprovement}\n\n`

  markdown += `### Phase 2: ${analysis.modernizationPlan.phase2.title}\n`
  markdown += `**Duration**: ${analysis.modernizationPlan.phase2.duration}\n\n`
  markdown += `**Tasks**:\n`
  analysis.modernizationPlan.phase2.tasks.forEach(task => {
    markdown += `- [ ] ${task}\n`
  })
  markdown += `\n**Expected Improvement**: ${analysis.modernizationPlan.phase2.expectedImprovement}\n\n`

  markdown += `### Phase 3: ${analysis.modernizationPlan.phase3.title}\n`
  markdown += `**Duration**: ${analysis.modernizationPlan.phase3.duration}\n\n`
  markdown += `**Tasks**:\n`
  analysis.modernizationPlan.phase3.tasks.forEach(task => {
    markdown += `- [ ] ${task}\n`
  })
  markdown += `\n**Expected Improvement**: ${analysis.modernizationPlan.phase3.expectedImprovement}\n\n`

  // Footer
  markdown += `---\n\n`
  markdown += `<div align="center">\n\n`
  markdown += `### ü§ñ Powered by CodeGenius AI\n\n`
  markdown += `This analysis was generated by **CodeGenius AI** - the intelligent codebase optimization platform.\n\n`
  markdown += `**Transform your codebase with AI-powered insights:**\n`
  markdown += `- üîç **Deep Analysis**: Comprehensive codebase examination\n`
  markdown += `- üöÄ **Performance Optimization**: Identify bottlenecks and improvements\n`
  markdown += `- üìä **Actionable Insights**: Prioritized recommendations with ROI\n`
  markdown += `- üõ†Ô∏è **Implementation Guidance**: Step-by-step improvement plans\n\n`
  markdown += `[![Try CodeGenius](https://img.shields.io/badge/Try%20CodeGenius-Analyze%20Your%20Code-brightgreen?style=for-the-badge&logo=robot)](https://codegenius.dev)\n\n`
  markdown += `---\n\n`
  markdown += `<sub>üìÖ Generated: ${formattedDate} | ü§ñ Powered by CodeGenius AI | ‚≠ê [Star this analysis](https://github.com/${repositoryInfo.fullName}) if it helped you!</sub>\n\n`
  markdown += `</div>`

  return markdown
}

// Regular POST endpoint for complete codebase analysis
export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions)
    
    if (!session || !session.accessToken) {
      return NextResponse.json(
        { error: "Unauthorized - No session or access token" }, 
        { status: 401 }
      )
    }

    const userId = session.user?.id || session.user?.githubId
    if (!userId) {
      return NextResponse.json(
        { error: "Unauthorized - No user ID available" }, 
        { status: 401 }
      )
    }

    const body: AnalyzeCodebaseRequest = await request.json()
    const { repositoryId, repositoryName, repositoryFullName, analysisType = 'complete' } = body

    if (!repositoryId || !repositoryName || !repositoryFullName) {
      return NextResponse.json(
        { error: "Missing required repository information" },
        { status: 400 }
      )
    }

    // Parse owner and repo from full name
    const [owner, repo] = repositoryFullName.split('/')
    if (!owner || !repo) {
      return NextResponse.json(
        { error: "Invalid repository full name format" },
        { status: 400 }
      )
    }

    // Initialize services
    const openai = new OpenAI({
      apiKey: process.env.OPENAI_API_KEY!,
    })
    
    const analyzer = new RepositoryAnalyzer(session.accessToken)
    const analysisService = new CodebaseAnalysisService(openai)

    // Get repository info and files
    const [repositoryInfo, allFiles] = await Promise.all([
      analyzer.getRepositoryInfo(owner, repo),
      analyzer.getAllRepositoryFiles(owner, repo)
    ])

    if (allFiles.length === 0) {
      return NextResponse.json(
        { error: "No suitable files found for analysis" },
        { status: 404 }
      )
    }

    // Analyze codebase with the new service
    let progress = 0
    const analysis = await analysisService.analyzeCodebase(
      allFiles,
      repositoryInfo,
      (event) => {
        progress = event.progress
        console.log(`Progress: ${event.progress}% - ${event.message}`)
      }
    )

    // Generate analysis report as markdown
    const markdownReport = await generateAnalysisReport(analysis, repositoryInfo, allFiles.length)

    // Save analysis to database (reusing the documentation structure for now)
    const savedAnalysis = await DocumentationService.saveDocumentation(
      userId,
      {
        id: repositoryId,
        name: repositoryInfo.name,
        fullName: repositoryInfo.fullName,
        description: repositoryInfo.description,
        language: repositoryInfo.language,
        topics: repositoryInfo.topics,
        htmlUrl: `https://github.com/${repositoryInfo.fullName}`,
      },
      {
        title: `${repositoryInfo.name} - Codebase Analysis Report`,
        markdownContent: markdownReport,
        structuredData: analysis as unknown as Record<string, unknown>,
        filesAnalyzed: allFiles.length,
      }
    )

    return NextResponse.json({
      success: true,
      repository: {
        id: repositoryId,
        name: repositoryInfo.name,
        fullName: repositoryInfo.fullName
      },
      analysis: {
        id: savedAnalysis.id,
        report: markdownReport,
        structured: analysis,
        overallScore: analysis.summary.overallScore,
        majorIssues: analysis.summary.majorIssues,
        quickWins: analysis.summary.quickWins,
        estimatedImprovementTime: analysis.summary.estimatedImprovementTime,
        potentialPerformanceGain: analysis.summary.potentialPerformanceGain
      },
      filesAnalyzed: allFiles.length,
      generatedAt: new Date().toISOString(),
      saved: true,
      analysisType,
      performance: {
        totalFiles: allFiles.length,
        finalProgress: progress
      }
    })

  } catch (error) {
    console.error("Error analyzing codebase:", error)
    
    if (error instanceof Error) {
      return NextResponse.json(
        { error: error.message },
        { status: 500 }
      )
    }
    
    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    )
  }
}

// Streaming endpoint for real-time analysis
export async function GET(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions)
    
    if (!session || !session.accessToken) {
      return new Response("Unauthorized", { status: 401 })
    }

    const userId = session.user?.id || session.user?.githubId
    if (!userId) {
      return new Response("Unauthorized", { status: 401 })
    }

    const url = new URL(request.url)
    const repositoryId = url.searchParams.get('repositoryId')
    const repositoryFullName = url.searchParams.get('repositoryFullName')

    if (!repositoryId || !repositoryFullName) {
      return new Response("Missing required parameters", { status: 400 })
    }

    const [owner, repo] = repositoryFullName.split('/')
    if (!owner || !repo) {
      return new Response("Invalid repository format", { status: 400 })
    }

    // Set up streaming response
    const encoder = new TextEncoder()
    
    const stream = new ReadableStream({
      start(controller) {
        const sendEvent = (data: StreamEvent) => {
          const event = `data: ${JSON.stringify(data)}\n\n`
          controller.enqueue(encoder.encode(event))
        }

        const analyzeCodebase = async () => {
          try {
            // Initialize services
            const openai = new OpenAI({
              apiKey: process.env.OPENAI_API_KEY!,
            })
            
            const analyzer = new RepositoryAnalyzer(session.accessToken!)
            const analysisService = new CodebaseAnalysisService(openai)

            // Get repository info and files
            sendEvent({ type: 'progress', message: 'Fetching repository data...', progress: 0 })
            
            const [repositoryInfo, allFiles] = await Promise.all([
              analyzer.getRepositoryInfo(owner, repo),
              analyzer.getAllRepositoryFiles(owner, repo)
            ])

            if (allFiles.length === 0) {
              sendEvent({ type: 'error', message: 'No suitable files found', progress: 0 })
              controller.close()
              return
            }

            // Analyze codebase with real-time progress
            const analysis = await analysisService.analyzeCodebase(
              allFiles,
              repositoryInfo,
              (event) => {
                sendEvent({
                  type: 'progress',
                  message: event.message,
                  progress: event.progress,
                  stage: event.type
                })
              }
            )

            // Generate report
            sendEvent({ type: 'progress', message: 'Generating analysis report...', progress: 90 })
            
            const markdownReport = await generateAnalysisReport(analysis, repositoryInfo, allFiles.length)

            // Save to database
            sendEvent({ type: 'progress', message: 'Saving analysis...', progress: 95 })
            
            const savedAnalysis = await DocumentationService.saveDocumentation(
              userId,
              {
                id: parseInt(repositoryId),
                name: repositoryInfo.name,
                fullName: repositoryInfo.fullName,
                description: repositoryInfo.description,
                language: repositoryInfo.language,
                topics: repositoryInfo.topics,
                htmlUrl: `https://github.com/${repositoryInfo.fullName}`,
              },
              {
                title: `${repositoryInfo.name} - Codebase Analysis Report`,
                markdownContent: markdownReport,
                structuredData: analysis as unknown as Record<string, unknown>,
                filesAnalyzed: allFiles.length,
              }
            )

            // Send final result
            sendEvent({
              type: 'complete',
              message: 'Analysis complete!',
              progress: 100,
              data: {
                success: true,
                repository: {
                  id: parseInt(repositoryId),
                  name: repositoryInfo.name,
                  fullName: repositoryInfo.fullName
                },
                analysis: {
                  id: savedAnalysis.id,
                  report: markdownReport,
                  structured: analysis,
                  overallScore: analysis.summary.overallScore,
                  majorIssues: analysis.summary.majorIssues,
                  quickWins: analysis.summary.quickWins
                },
                filesAnalyzed: allFiles.length,
                generatedAt: new Date().toISOString(),
                saved: true
              }
            })

            controller.close()

          } catch (error) {
            console.error('Streaming analysis error:', error)
            sendEvent({
              type: 'error',
              message: error instanceof Error ? error.message : 'Unknown error',
              progress: 0
            })
            controller.close()
          }
        }

        analyzeCodebase()
      }
    })

    return new Response(stream, {
      headers: {
        'Content-Type': 'text/event-stream',
        'Cache-Control': 'no-cache',
        'Connection': 'keep-alive',
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Methods': 'GET',
        'Access-Control-Allow-Headers': 'Content-Type',
      },
    })

  } catch (error) {
    console.error("Streaming endpoint error:", error)
    return new Response("Internal server error", { status: 500 })
  }
}
